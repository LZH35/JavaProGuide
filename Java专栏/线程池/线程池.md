> 你说下线程池的大小要怎么配置？

这个问题要看业务系统执行的任务更多的是计算密集型任务，还是I/O密集型任务。大家可以在这两个方面来回答面试官。

（1）如果是计算密集型任务，通常情况下，CPU个数为N，设置N + 1个线程数量能够实现最优的资源利用率。因为N + 1个线程能保证**至少有N个**线程在利用CPU，提高了CPU利用率；同时不设置过多的线程也能减少线程状态切换所带来的上下文切换消耗。

（2）如果是I/O密集型任务，线程的主要等待时间是花在等待I/O操作上，另外就是计算所花费的时间。一般可以根据这个公式得出线程池合适的大小配置。
$$
线程池大小 = CPU数量 * CPU期望的利用率 * (1 + IO操作等待时间/CPU计算时间)
$$

> 线程池怎么创建呢？

可以使用ThreadPoolExecutor自定义创建线程池，也是创建线程池推荐的创建方式。

```java
    public ThreadPoolExecutor(int corePoolSize, // 要保留在池中的线程数
                              int maximumPoolSize, // 池中允许的最大线程数
                              long keepAliveTime, // 当线程数大于corePoolSize时，多余的空闲线程在终止之前等待新任务的最长时间
                              TimeUnit unit, // 时间单位
                              BlockingQueue<Runnable> workQueue, // 在执行任务之前用于保存任务的队列
                              ThreadFactory threadFactory) { // 执行程序创建新线程时使用的工厂
        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
             threadFactory, defaultHandler);
    }
```

另外Executors类也提供了一些静态工厂方法，可以用来创建一些预配置的线程池。

设置线程池的线程数上限

```java
    public static ExecutorService newFixedThreadPool(int nThreads) {
        return new ThreadPoolExecutor(nThreads, nThreads,
                                      0L, TimeUnit.MILLISECONDS,
                                      new LinkedBlockingQueue<Runnable>());
    }
```

让线程按序执行

```java
    public static ExecutorService newSingleThreadExecutor() {
        return new FinalizableDelegatedExecutorService
            (new ThreadPoolExecutor(1, 1,
                                    0L, TimeUnit.MILLISECONDS,
                                    new LinkedBlockingQueue<Runnable>()));
    }
```

创建可缓存的线程池

```java
    public static ExecutorService newCachedThreadPool() {
        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                      60L, TimeUnit.SECONDS,
                                      new SynchronousQueue<Runnable>());
    }
```

创建可以执行延迟任务的线程池

```java
    public static ScheduledExecutorService newScheduledThreadPool(
            int corePoolSize, ThreadFactory threadFactory) {
        return new ScheduledThreadPoolExecutor(corePoolSize, threadFactory);
    }
```

不过小伙伴要记得以上模板在使用过程中可能会出现OOM内存溢出的情况。

1. newFixedThreadPool、newSingleThreadExecutor：创建线程池指定的请求队列类型是`new LinkedBlockingQueue<Runnable>()`，故允许的请求队列长度是Integer.MAX_VALUE，会产生OOM内存溢出
2. newCachedThreadPool、newScheduledThreadPool：创建线程池指定的线程数上限是Integer.MAX_VALUE，故允许创建的线程数Integer.MAX_VALUE，会产生OOM内存溢出

> 你们项目用的这种创建方式？

一般Spring工程是不直接使用ThreadPoolExecutor的。

Spring框架提供了以Bean形式来配置线程池的ThreadPoolTaskExecutor类，ThreadPoolExecutor类的底层实现还是基于JDK的ThreadPoolExecutor。

```java
    @Bean(name = "testExecutor")
    public ThreadPoolTaskExecutor test() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        // 配置核心线程数
        executor.setCorePoolSize();
        // 配置最大线程数
        executor.setMaxPoolSize();
        // 配置队列大小
        executor.setQueueCapacity();
        executor.initialize();
        return executor;
    }
```

