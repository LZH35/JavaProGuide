## 1. 可重入锁

> ***面试官：知道可重入锁有哪些吗?***

知道的面试官。可重入意味着获取锁的粒度是**线程**而不是**调用**，我了解的主要有ReentrantLock、**sychronized**都是可重入锁。

## 2. synchronized实现原理

> ***面试官：你先说说synchronized的实现原理?***

好的，synchronized的实现是基于monitor的。

是这样，任何对象都有一个**monitor**与之关联，当monitor被持有后，对象就会处于**锁定状态**。

而在同步代码块的**开始位置**，在编译期间会被插入**monitor'enter指令**。

当线程执行到monitorenter指令时，就会尝试获取**monitor**的所有权，获取得到则获得锁资源。

### 2.1 synchronized的缺点

> ***面试官：那synchronized有什么缺点？***

缺点是资源消耗是比较大，因为它是属于**重量级锁**。

1. synchronized需要频繁的**获得锁、释放锁**，这会带来了不少性能消耗。

2. 另外没有获得锁的线程会被**操作系统**进行挂起阻塞、唤醒。

   而**唤醒操作**需要保存当前线程状态，切换到下一个线程，也就是进行**上下文切换**。

   上下文切换是很耗费资源的一种操作。

### 2.2 保存当前线程状态

> ***面试官：为什么上下文切换要保存当前线程状态？***

emmm就跟读英文课文时查字典一样，我们要先记住课文里的**页数**，查完字典好回到英文课文。

而CPU需要保存当前线程的状态，来保证可以**切换**到上一个线程的状态。

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/89625c609b3a4a38bd84a234fae3ccf1.png#pic_center)

### 2.3 解决synchronized资源消耗

> ***面试官：可以怎么解决synchronized资源消耗吗？***

JDK在这方面是引入了偏向锁、轻量级锁、重量级锁，也就是**锁升级**。

多线程环境其实有各种不同的场景，这三种锁就是为了**适应各种不同场景**，来使并发的效率最高。

1. 只有**一个线程**访问同步代码块的场景的话，会进入偏向锁状态。

   偏向锁会**偏向访问它的线程**，使其加锁、解锁不需要额外的消耗。

2. 有**少量线程竞争**的场景的话，偏向锁会**升级为轻量级锁**。

   而轻量级使用**CAS操作**来获得锁，CAS操作**不需要获得锁、释放锁**，减少了像synchronized带来的**上下文切换**资源消耗。

### 2.4 轻量级锁缺点

> ***面试官：那轻量级锁没有缺点吗？***

有的，没有获得锁的线程会**自旋**，这需要消耗**CPU**的。

另外如果**自旋10次失败**的话，为了**减少CPU的消耗**，轻量级锁会升级为**重量级锁**，也就是回到了类似synchronized重量级锁的同步场景。

