线程开始运行，拥有自己的栈空间，就如同一个脚本一样，按照既定的代码一步一步地执行，直到终止。但是，每个运行中的线程，如果仅仅是孤立地运行，那么没有一点儿价值，或者说价值很少，如果多个线程能够相互配合完成工作，这将会带来巨大的价值。



> 知道线程的等待/通知机制嘛？

Java线程的等待/通知机制指的是：线程A获得了锁资源后调用了锁对象的wait()方法，释放锁的同时进入**等待状态**；而线程B获得锁资源后，再通过锁对象的notify()或notifyAll()方法来**通知**线程A恢复执行逻辑。

其实Java的所有对象都拥有等待/通知机制的本领，大家可以在JDK源码package java.lang`下找到Java.lang.Object里提供的五个与等待/通知机制相关的方法。

一、等待。

（1）使当前线程等待，直到另一个线程调用此对象的notify()方法或notifyAll()方法。

```java
    public final void wait() throws InterruptedException {
        wait(0);
```

（2）使当前线程等待，直到另一个线程调用此对象的notify()方法或notifyAll()方法，或者指定的毫秒timeout过去。

```java
    public final native void wait(long timeout) throws InterruptedException;
```

（3）使当前线程等待，直到另一个线程调用此对象的notify()方法或notifyAll()方法，或者指定的毫秒timeout过去，另外nanos是额外时间，以纳秒为单位。

```java
    public final void wait(long timeout, int nanos) throws InterruptedException {
    }
```

所以其实wait()、watit(0)、watit(0, 0)执行后都是**同样的效果**。

二、通知。

（1）唤醒在此对象监视器上等待的单个线程。

```java
    public final native void notify();
```

（2）唤醒在此对象监视器上等待的所有线程。

```java
    public final native void notifyAll();
```

大家有没听说过消费者、生产者问题呢？消费者生产者之间要无限循环生产和消费物品，解决之道就是两者形成完美的等待、通知机制。而这套机制就可以通过上文的wait、notify方法来实现。



> 还有其他通信方法吗？

