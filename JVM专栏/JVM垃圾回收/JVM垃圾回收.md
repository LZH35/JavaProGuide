经过半个多世纪的发展，目前内存的动态分配与内存回收技术已经相当成熟，一切看起来都进入了“自动化”时代，那为什么我们还要去了解GC和内存分配呢？答案很简单：当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就需要对这些“自动化”的技术实施必要的监控和调节。

## 1. 垃圾回收算法

### 1.1 引用计数法

> ***面试官：JVM为什么不采用引用计数法？***

引用计数法为每个Java对象添加一个**引用计数器**，引用失效了计数器就-1，有新的引用就+1，通过计数器的数值来判断该对象是否是垃圾对象。

大家看下这个例子，如果对象A和对象B没有被任何对象去引用，也没有被任何线程访问，这两个对象按理应该被回收。但如果对象A的成员变量引用了对象B，对象B的成员变量引用了对象A，它们的引用计数器数值都**不为0**，通过引用计数法并不能将其视为垃圾对象。

```java
    class A {
        B b = new B();
    }
    class B {
        A a = new A();
    }
```

引用计数法就因为很难解决对象之间相互**循环引用**的问题，所以目前都是采用可达性分析算法来判断对象是否是垃圾对象。

### 1.2 可达性分析算法

> ***面试官：那可达性分析算法是什么？***

可达性分析顾名思义就是以某个起始点来判断它是否可达，而这个起始点称为GC Roots。可以把GC Roots当成二叉树的根节点，与GC Roots可达的对象形成一棵二叉树，如果Java对象不能从GC Roots往下搜索到，那该对象就被视为垃圾对象。

图片

GC Roots对象一共包括以下四种：

1. 虚拟机栈中引用的对象。
2. 本地方法栈中引用的对象。
3. 方法区中类静态属性引用的对象。
4. 方法区中常量引用的对象。

## 2. 垃圾回收

### 2.1 回收垃圾区域

> ***面试官：垃圾回收器回收的是哪个区域？***

JVM由五大区域组成：堆内存、方法区、程序计数器、虚拟机栈、本地方法栈。先说结论，垃圾回收器回收的是**堆内存和方法区**。

程序计数器、虚拟机栈、本地方法栈的内存分配和回收都具备确定性，都是随着线程销毁而销毁，因此**不需要进行回收**。

但在堆内存、方法区中，内存分配和回收都是**动态**的，我们只有在**运行期间**才能知道会创建哪些对象；另外这些垃圾对象不会自动销毁，如果任由这两部分区域的垃圾对象不管，势必造成内存的浪费甚至有内存泄漏的可能。

垃圾回收器存在的意义就是通过自动检测和回收这些垃圾对象，来减少内存泄漏的风险。

### 2.2 永久代会回收吗

> ***面试官：永久代还会进行垃圾回收吗？***

虽然永久代的垃圾回收效率是比较低的，但永久代里的**废弃常量和无用的类**仍然会被回收。

例如创建一个字符串常量name，该字符串会存在于常量池中。如果该字符串没有任何String对象去引用它，当发生内存回收时有必要会清除该废弃常量。

```java
private static final String name = "JavaGetOffer";
```

### 2.3 垃圾回收器

> ***面试官：你说说都有哪些垃圾回收器？***

1. Serial是一个**新生代**的**单线程**垃圾回收器。在垃圾回收期间系统的所有线程都会阻塞，但垃圾回收效率因此也**效率高**。

2. ParNew则是Serial的**多线程版本**。这也是第一款并发的垃圾回收器，相比Serial来说垃圾回收不需要阻塞所有线程，第一次实现了让垃圾回收线程和用户线程同时工作。

3. Serial Old是Serial的**老年代版本。**

4. Parallel Scavenge同样是作用在**新生代**且是**多线程**，不过它的设计目标是达到一个可控制的**吞吐量**。

5. Parallel Old是Parallel Scavenge收集器的**老年代版本**，我们可以把它和Parallel Scavenge搭配一起使用。

6. CMS是一种以**最短停顿时间**为目标的**多线程**收集器，下文我会介绍CMS实现最短停顿的原理。

7. G1收集器可以说是CMS的**升级版**。

我们可以根据业务实际情况来为各个年代搭配不同的垃圾回收器，以下的垃圾回收器如果有线连接，说明它们之间可以搭配使用。

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/fab15188c52744a2833dd93794a03496.png#pic_center)

### 2.4 CMS原理

> ***面试官：CMS为什么有较短的停顿呢？***

CMS采用了**标记-清除**算法，整个运作过程分为了初始标记、并发标记、重新标记、并发清除四个阶段。

其中初始标记、重新标记的停顿时间是比较短的，而**耗时最长**的并发标记、并发清除能够和用户线程一起**并发工作不需要停顿**，可以说CMS只需要造成初始标记、重新标记带来的短时间停顿。

### 2.5 CMS的缺点

> ***面试官：那它有什么缺点？***

1. CMS是**多线程**的，在垃圾回收时会占用一部分线程，可能会使系统变得相对较慢。
2. CMS并发清理时用户线程还在运行着，也就是说还会有新的垃圾不断产生，这些垃圾被称为浮动垃圾。而CMS本次收集是无法处理这些**浮动垃圾**的。
3. CMS采用**标记-清除**算法，而标记-清除算法的缺点是会产生空间碎片，有可能造成大对象找不到足够的连续空间发生OOM的情况。

### 2.6 G1垃圾回收器

> ***面试官：你说G1是CMS的升级版，为什么？***

G1垃圾回收器设计之初被赋予的使命是未来可以替换掉JDK1.5中发布的CMS垃圾回收器。所以CMS垃圾回收器的优点G1都有，另外G1垃圾回收器也避免了CMS的一些不足。

1. G1采用了标记-整理算法，该算法在内存到达一定量后，会把所有已标记的垃圾对象都向一端里移动，然后以存活对象所在的一端为边界，清除边界内所有内存，避免了CMS采用**标记-清除**可能产生的空间碎片。
2. 其他收集器在新生代、老年代分别采用**不同收集器进行配合**，而G1可以不需要其他收集器配合就能独立管理整个GC。



## 3. 垃圾回收算法

### 



### 优化复制算法

> ***面试官：复制算法可以优化吗？***

复制算法把内存划分为容量相等的两块，也就是按1：1分配内存，但这也**浪费了50%空间**。

可以把内存分为一块**较大的Eden空间和两块较小的Survivor空间**，每次只使用Eden空间和其中一块Survivor空间，而另一块Survivor空间用来保存回收时**还存活的对象**。这样就只浪费了其中一块Survivor空间的内存。
