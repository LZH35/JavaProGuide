## 1. 垃圾回收算法

> ***面试官：知道垃圾回收为什么不采用引用计数法吗？***

知道的面试官。主要是因为它很难解决对象之间相互**循环引用**的问题，所以目前都是采用可达性分析算法。

## 2. java引用类型

> ***面试官：说到引用，java有什么引用类型？***

有4种，强引用、软引用、弱引用、虚引用。

## 3. 垃圾回收

> ***面试官：垃圾回收的是新生代、老年代对吧？那永久代还会进行回收吗？***

会的，永久代里的**废弃常量和无用的类**会被回收。

例如类里面的**常量**没有其他任何引用，如果发生内存回收，有必要的话会进行清理。

### 3.1 回收垃圾区域

> ***面试官：垃圾回收器回收的是哪个区域的垃圾？***

主要是回收**堆内存和方法区**。

是这样的，程序计数器、虚拟机栈、本地方法栈的内存分配和回收具备确定性，都是随着线程销毁而销毁**不需要进行回收**。

但在堆内存、方法区在内存分配和回收都是**动态**的，我们只有在**运行期间**才能知道会创建哪些对象。

### 3.2 垃圾回收器

> ***面试官：你说说都有哪些垃圾回收器？***

好的。

1. Serial是一个**新生代**的**单线程**垃圾回收器

   在垃圾回收期间系统的所有线程都会阻塞，但垃圾回收效率因此也**效率高**。

2. ParNew则是Serial的**多线程版本**

3. Serial Old是Serial的**老年代版本**

4. Parallel Scavenge同样是作用在**新生代**且是**多线程**，不过它的目标是高的**吞吐量**

5. Parallel Old是Parallel Scavenge收集器的**老年代版本**，可以配和Parallel Scavenge一起使用

6. CMS是一种以**最短停顿时间**为目标的**多线程**收集器

7. G1收集器可以说是CMS的**升级版**

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/fab15188c52744a2833dd93794a03496.png#pic_center)

### 3.3 高吞吐量和短停顿时间

> ***面试官：高吞吐量和停顿时间短有什么好处吗？***

两者适合不同的业务场景。

1. 停顿时间少适合用户交互多的程序，可以让用户的**体验更流畅**
2. 而高吞吐量可以**高效率地利用CPU时间**，适合**后台运算操作多**的程序

### 3.4 CMS原理

> ***面试官：刚刚你说CMS为什么有较短的停顿呢？***

是这样的，CMS采用了**标记-清除**算法。

分为了初始标记、并发标记、重新标记、并发清除四个阶段。

**耗时最长**的并发标记、并发清除可以和用户线程一起**并发工作不需要停顿**，其他阶段的耗时较短也就是说停顿也短。

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/eb6a676e4e3a42818c28ddee14391676.png#pic_center)

### 3.5 CMS的缺点

> ***面试官：那它有什么缺点？***

1. 它是**多线程**的，导致占用一部分线程会使程序变慢
2. CMS并发清理时用户线程还在运行着，也就是说还会有新的垃圾不断产生，CMS本次收集是无法处理这些**浮动垃圾**的
3. 因为是采用**标记-清除**算法，有可能有产生空间碎片

### 3.6 G1垃圾回收器

> ***面试官：你说G1是CMS的升级版，为什么？***

主要是CMS的优点它都有，另外G1也避免了CMS的一些不足。

1. G1采用了标记-整理算法，避免了CMS采用**标记-清除**可能产生的空间碎片
2. 其他收集器在新生代、老年代分别采用**不同收集器进行配合**。而G1可以不需要其他收集器配合就能独立管理整个GC

## 4. Minor GC和Full GC

> ***面试官：知道Minor GC和Full GC有什么区别吗？***

- Minor GC是发生在新生代，采用**复制算法**进行回收
- Full GC是发生在新生代和老年代，采用的垃圾回收算法可以有多种

## 5. 优化复制算法

> ***面试官：复制算法可以优化吗？***

可以的。复制算法一般是按1：1分配内存，但这也**浪费了50%空间**。

其实可以把内存分为一块**较大的Eden空间和两块较小的Survivor空间**，每次使用Eden和其中一块Survivor，而另一块Survivor用来保存回收时**还存活的对象**。

这样只浪费了其中一块Survivor空间的内存。
