## 1. 索引类型


> ***面试官：知道索引有什么类型吗？***

关于加速数据检索的索引，我了解的主要有B树索引、哈希索引。

### 1.1 B-Tree索引

> ***面试官：B树索引说一下？***

好的面试官。

1. 在**结构方面**，B-Tree不同于二叉搜索树，它是**多子树的**。
2. 在**值的存储方面**，所有的值都存储在叶子节点，且叶子节点可以存储多个值。
3. 另外叶子节点之间用指针链接形成**双向链表**。如果是二级索引建立的B-Tree，每个叶子节点的值有保存**对应行数据的主键**。

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/4cc6c9c3150c4365bf5ad7405e554585.png#pic_center)

### 1.2 B-Tree值的存储

> ***面试官：你说值都存储在叶子节点，那有什么好处？***

有两方面。

值都存储在叶子节点，使得非叶子节点**层数更少**，整棵B-Tree的高度变得矮胖，可以**提高搜索的效率**。

另外业务上一般都是**范围查询**，值都存储叶子节点同时形成双向链表，很适合范围查询。

### 1.3 哈希索引

> ***面试官：知道为什么主流数据库引擎不采用哈希索引吗？***

hhh就像我刚刚说的，业务上一般都是**范围查询**，而哈希索引不支持任何范围查询。

哈希索引会为所有的索引列计算一个哈希码，在哈希表中保存哈希码和指向每个数据行的指针，这种结构对**精确匹配查询**效率才高。

## 2. 聚簇索引

> ***面试官：聚簇索引和二级索引有什么关联？***

好的面试官。

是这样的，**二级索引指的是非主键索引**，它的叶子节点保存的只是**行的主键值**，所以需要通过主键来找到行数据。

而聚簇索引是通过**主键来建树**，叶子节点包含了**行的全部数据**，主键索引就是聚簇索引。

所以**通过二级索引查找行**，需要先在二级索引**建立**的B-Tree上找到主键值，再从聚簇索引建立的B-Tree找到行数据。

## 3. 索引效率

> ***面试官：那我一条SQL，我怎么知道它有没使用到索引？***

可以使用**Explain关键字**来分析，它会模拟执行sql语句，查询出sql语句**执行的相关信息**，如哪些索引可以被命中、哪些索引实际被命中。

我说下Explain查询结果的几个关键字段。

- **type**

  - cost：通过索引**一次**查询
  - ref：使用到索引
  - range: 使用到索引
  - all：**全表扫描**

- **Extra**

  - using filesort：使用外部文件排序，发生在无法使用索引的情况下

  - using index：**where查询**的列**被**索引覆盖，直接通过索引就可以查询到数据

  - using where：**where查询**的列，没有**全部被**索引覆盖

  - using join buffer：使用了连接缓存

- **possible_key**

  表示可以使用的索引

- **key**

  表示实际使用的索引

### 3.1 索引失效

> ***面试官：有没索引失效的情况呢？***

有的，索引失效一般是这个SQL查询破坏了**使用B-Tree查询**的条件。

- 对索引列进行**数学函数**处理的话，索引会失效

- 索引是字符串类型，查询值没有添加**单引号**''那索引会失效。因为值类型与索引列类型不一致，MySQL**不会使用**索引，而是把索引列数据进行**类型转换**后进行查询

- 对索引列进行模糊查询，%要放在**最右侧**，否则索引失效

  ```sql
  SELECT * FROM user WHERE name LIKE n%
  ```

- 组合索引，前一个索引使用**范围查询**，后面的索引也会失效
