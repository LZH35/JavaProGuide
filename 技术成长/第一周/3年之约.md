## 20240714：Java在开发中常见的异常是什么？

1. ClassNotFoundException
2. FileNotFoundException
3. NullPointerException
4. ClassCastException
5. IndexOutOfBoundException

群里小伙伴有趣的回答：NoGirlFriendException、下班异常



## 20240715：那JDK和CGLIB动态代理哪个更快？

JDK动态代理通过生成代理对象的**字节码文件**，使要拦截的方法跳转到invoke()方法，而在invoke()里就是在**切面**里定义的各种拦截逻辑。

而CGLIB是通过生成代理类的**子类实现**，同时**修改字节码**文件让子类方法覆盖代理类的方法，从而实现对拦截方法的代理。

以上两者的生命周期可以分为：创建对象阶段、实际运行阶段，我们要根据具体情况具体分析。

1. 在**实际运行**阶段，CGLIB动态代理性能比JDK动态代理运行性能更高。
2. 在**创建对象**阶段，基于两者的原理，CGLIB花费在创建对象的时间要比JDK多。JDK只需创建代理类的字节码，而CGLIB既要修改源代码的字节码文件，又要生成代理类的子类字节码文件，明显消耗的时间更多。

综上所述，对于需要创建大量对象的场景，JDK动态代理比CGLIB动态代理效率更高，反之CGLIB动态代理效率更高。



## 20240716：你说说Redis五大基本数据类型？

（1）字符串

字符串是Redis最基础，也是业务开发中最常见的一种键值数据类型。

```sh
127.0.0.1:6379> set name JavaProGuide
OK
127.0.0.1:6379> get name
"JavaProGuide"
```

（2）哈希

哈希的键值本身是一个**键值对结构**，类似于`key = {{field, value}, {field, value}}`。

```sh
127.0.0.1:6379> hset msg name JavaProGuide
(integer) 1
127.0.0.1:6379> hget msg name
"JavaProGuide"
```

（3）列表

Redis的列表是一个**有序列表**，但大家注意一点，此处所说的**有序**不是按数据大小排序的有序，而是按插入顺序的有序。

```sh
# 从右边添加
127.0.0.1:6379> rpush number 1 2 3
(integer) 3
127.0.0.1:6379> lrange number 0 2
4) "1"
5) "2"
6) "3"
```

（4）集合

集合类型和列表不同之处在于它是无序的，同时也不支持保存**重复的元素**。另外两个集合之间可以获得**交集、并集、差集**。

```sh
127.0.0.1:6379> sadd user:1:like game bask run
(integer) 3
127.0.0.1:6379> sadd user:2:like game basketball fitness
(integer) 3
# 求交集
127.0.0.1:6379> sinter user:1:like user:2:like
1) "game"
```

（5）有序集合

有序集合算是Redis中比较特殊的一种数据类型，有序集合里的每个元素都带有一个score属性，我们可以利用score属性来对键值对进行排序。

```sh
127.0.0.1:6379> zadd 100run:ranking 13 mike
(integer) 1
127.0.0.1:6379> zadd 100run:ranking 12 jake
(integer) 1
127.0.0.1:6379> zrange 100run:ranking 0 1
1) "jake"
2) "mike"
```



## 20240717：知道有哪些索引失效的情况？

索引失效一般是这个SQL查询破坏了**使用B-Tree查询**的条件。也有一种可能出现，如果表数据膨胀得太快，即使建立索引你查询起来也会有索引失效的错觉，这个问题就要另外讨论了。

（1）如果在where子句中使用not in、!=和＜＞操作，会使索引失效而导致进行全表扫描。

```sql
SELECT * FROM employees WHERE department_id NOT IN (3, 5, 7);
```

（2）对索引列进行**数学函数**处理的话，索引会失效。

```sql
SELECT * FROM employees WHERE ABS(salary) = 5000;
```

（3）索引是字符串类型，查询值没有添加**单引号**`''`，会导致索引会失效。因为值类型与索引列类型。不一致，MySQL**不会使用**索引，而是把索引列数据进行**类型转换**后进行查询。

```sql
SELECT * FROM books WHERE ISBN = 9780132350884;
```

（4）对索引列进行模糊查询，%要放在**最右侧**，否则索引会失效。

```sql
SELECT * FROM employees WHERE name LIKE n%
```

（5）在组合索引中，如果前一个索引使用**范围查询**，后面的索引也会失效。

```sql
SELECT * FROM orders WHERE customer_id > 1000 AND order_date = '2024-07-16';
```

大家在实际工作切忌乱加索引，此`切忌`非`切记`。每加一次索引，MySQL都要多去维护一棵新的B-Tree。增加太多索引，数据查询效率会变得低下。


## 20240718：Mybatis的缓存有哪几种？

软件系统合理使用缓存有一个好处。有了缓存，在原始数据没有更新的情况下，我们不需要重新再去获取一遍数据，这也减少了数据库IO，达到提升数据库性能的目的。

MyBatis同样提供了两个级别的缓存，一级缓存是基于qlSession实现，二级缓存是基于Mapper实现。

（1）一级缓存

一级缓存作用在同一个SqlSession对象中，当SqlSession对象失效则一级缓存也跟着失效。我们梳理下一级缓存的**生命周期**。首先第一次查询时会把查询结果写入SqlSession缓存，如果第二次查询时原始数据没有改变则会读取缓存，但如果是修改、删除、添加语句的执行，那SqlSession缓存会被全部清空掉，这也是为了防止**脏读**的出现。

一级缓存缓存底层使用的是一个简单的Map数据结构来存储缓存，其中key为`SQL + 参数`、val为`查询结果集`。一级缓存的生命周期如下。

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/7ffbd58ab80d460a877dd0cba43de01b.png#pic_center)

（2）二级缓存

二级缓存的作用域是同一个命名空间**namespace**的Mapper对象，也就是说同一个Mapper下的多个SqlSession是可以共用二级缓存的。二级缓存的缓存写入、清空流程和一级缓存相似，但二级缓存的生命周期是和**应用程序的生命周期**一致的。为什么？因为Mybatis框架与Spring IOC集成的Mapper对象是单例对象。

另外大家还需要注意下，Mybatis的一级缓存是默认开启的且**不能关闭**，而二级缓存则需要我们手动开启，我们需要在配置文件中配置`cacheEnabled`参数。

```xml
<configuration>
  <settings>
    <setting name="cacheEnabled" value="true"/>
  </settings>
```
