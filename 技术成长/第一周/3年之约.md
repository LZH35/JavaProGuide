## 20240714：Java在开发中常见的异常是什么？

1. ClassNotFoundException
2. FileNotFoundException
3. NullPointerException
4. ClassCastException
5. IndexOutOfBoundException

群里小伙伴有趣的回答：NoGirlFriendException、下班异常



## 20240715：那JDK和CGLIB动态代理哪个更快？

JDK动态代理通过生成代理对象的**字节码文件**，使要拦截的方法跳转到invoke()方法，而在invoke()里就是在**切面**里定义的各种拦截逻辑。

而CGLIB是通过生成代理类的**子类实现**，同时**修改字节码**文件让子类方法覆盖代理类的方法，从而实现对拦截方法的代理。

以上两者的生命周期可以分为：创建对象阶段、实际运行阶段，我们要根据具体情况具体分析。

1. 在**实际运行**阶段，CGLIB动态代理性能比JDK动态代理运行性能更高。
2. 在**创建对象**阶段，基于两者的原理，CGLIB花费在创建对象的时间要比JDK多。JDK只需创建代理类的字节码，而CGLIB既要修改源代码的字节码文件，又要生成代理类的子类字节码文件，明显消耗的时间更多。

综上所述，对于需要创建大量对象的场景，JDK动态代理比CGLIB动态代理效率更高，反之CGLIB动态代理效率更高。



## 20240716：你说说Redis五大基本数据类型？

（1）字符串

字符串是Redis最基础，也是业务开发中最常见的一种键值数据类型。

```sh
127.0.0.1:6379> set name JavaProGuide
OK
127.0.0.1:6379> get name
"JavaProGuide"
```

（2）哈希

哈希的键值本身是一个**键值对结构**，类似于`key = {{field, value}, {field, value}}`。

```sh
127.0.0.1:6379> hset msg name JavaProGuide
(integer) 1
127.0.0.1:6379> hget msg name
"JavaProGuide"
```

（3）列表

Redis的列表是一个**有序列表**，但大家注意一点，此处所说的**有序**不是按数据大小排序的有序，而是按插入顺序的有序。

```sh
# 从右边添加
127.0.0.1:6379> rpush number 1 2 3
(integer) 3
127.0.0.1:6379> lrange number 0 2
4) "1"
5) "2"
6) "3"
```

（4）集合

集合类型和列表不同之处在于它是无序的，同时也不支持保存**重复的元素**。另外两个集合之间可以获得**交集、并集、差集**。

```sh
127.0.0.1:6379> sadd user:1:like game bask run
(integer) 3
127.0.0.1:6379> sadd user:2:like game basketball fitness
(integer) 3
# 求交集
127.0.0.1:6379> sinter user:1:like user:2:like
1) "game"
```

（5）有序集合

有序集合算是Redis中比较特殊的一种数据类型，有序集合里的每个元素都带有一个score属性，我们可以利用score属性来对键值对进行排序。

```sh
127.0.0.1:6379> zadd 100run:ranking 13 mike
(integer) 1
127.0.0.1:6379> zadd 100run:ranking 12 jake
(integer) 1
127.0.0.1:6379> zrange 100run:ranking 0 1
1) "jake"
2) "mike"
```



## 20240717：知道有哪些索引失效的情况？

索引失效一般是这个SQL查询破坏了**使用B-Tree查询**的条件。也有一种可能出现，如果表数据膨胀得太快，即使建立索引你查询起来也会有索引失效的错觉，这个问题就要另外讨论了。

（1）如果在where子句中使用not in、!=和＜＞操作，会使索引失效而导致进行全表扫描。

```sql
SELECT * FROM employees WHERE department_id NOT IN (3, 5, 7);
```

（2）对索引列进行**数学函数**处理的话，索引会失效。

```sql
SELECT * FROM employees WHERE ABS(salary) = 5000;
```

（3）索引是字符串类型，查询值没有添加**单引号**`''`，会导致索引会失效。因为值类型与索引列类型。不一致，MySQL**不会使用**索引，而是把索引列数据进行**类型转换**后进行查询。

```sql
SELECT * FROM books WHERE ISBN = 9780132350884;
```

（4）对索引列进行模糊查询，%要放在**最右侧**，否则索引会失效。

```sql
SELECT * FROM employees WHERE name LIKE n%
```

（5）在组合索引中，如果前一个索引使用**范围查询**，后面的索引也会失效。

```sql
SELECT * FROM orders WHERE customer_id > 1000 AND order_date = '2024-07-16';
```

大家在实际工作切忌乱加索引，此`切忌`非`切记`。每加一次索引，MySQL都要多去维护一棵新的B-Tree。增加太多索引，数据查询效率会变得低下。


## 20240718：Mybatis的缓存有哪几种？

软件系统合理使用缓存有一个好处。有了缓存，在原始数据没有更新的情况下，我们不需要重新再去获取一遍数据，这也减少了数据库IO，达到提升数据库性能的目的。

MyBatis同样提供了两个级别的缓存，一级缓存是基于qlSession实现，二级缓存是基于Mapper实现。

（1）一级缓存

一级缓存作用在同一个SqlSession对象中，当SqlSession对象失效则一级缓存也跟着失效。我们梳理下一级缓存的**生命周期**。首先第一次查询时会把查询结果写入SqlSession缓存，如果第二次查询时原始数据没有改变则会读取缓存，但如果是修改、删除、添加语句的执行，那SqlSession缓存会被全部清空掉，这也是为了防止**脏读**的出现。

一级缓存缓存底层使用的是一个简单的Map数据结构来存储缓存，其中key为`SQL + 参数`、val为`查询结果集`。一级缓存的生命周期如下。

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/7ffbd58ab80d460a877dd0cba43de01b.png#pic_center)

（2）二级缓存

二级缓存的作用域是同一个命名空间**namespace**的Mapper对象，也就是说同一个Mapper下的多个SqlSession是可以共用二级缓存的。二级缓存的缓存写入、清空流程和一级缓存相似，但二级缓存的生命周期是和**应用程序的生命周期**一致的。为什么？因为Mybatis框架与Spring IOC集成的Mapper对象是单例对象。

另外大家还需要注意下，Mybatis的一级缓存是默认开启的且**不能关闭**，而二级缓存则需要我们手动开启，我们需要在配置文件中配置`cacheEnabled`参数。

```xml
<configuration>
  <settings>
    <setting name="cacheEnabled" value="true"/>
  </settings>
```



## 20240719：Redis主从数据同步过程你说一说？

Redis作为一个非关系型数据库，**主从架构**的目的就在于对数据有多个"备份"，有了多个"备份"，就自然而然衍生出众多好处。如负载均衡、灾难恢复、数据备份。

既然要"备份"，那数据同步就必不可少了。Redis主从数据同步大致的过程如下。

（1）首先，从服务器会先向主服务器发送**SYNC命令**。

（2）收到命令后，Redis主服务器会执行**BGSAVE命令**来生成一个**RDB文件**，并使用**AOF缓冲区**来记录在生成期间执行的写命令。关于BGSAVE命令和SAVE命令的区别，大家可以往前阅读我写的Redis系列文章。

（3）完成第二步后，主服务器会将RDB文件发送给从服务器，让从服务器同步RDB文件数据。

（4）当然这还没完，在生成RDB文件的过程中，仍然会有其他写命令到达服务器。Redis主服务器的AOF缓冲区会继续发送给从服务器，让它们之间的数据同步至**最终状态**。



## 20240720：你说说Kafka由什么模块组成？

Kafka其实是一款基于**发布与订阅模式**的消息系统，如果按常理来设计，大家是不是把消息发送者的消息直接发送给消息消费者？但Kafka并不是这么设计的，Kafka消息的生产者会对消息进行分类，再发送给中间的消息服务系统，而消息消费者通过订阅某分类的消息去接受特定类型的消息。

其实这么设计的目的也是为了满足大量业务消息的接入，要是单一的消息发送和接收，那开个进程的**管道通信**就可以了。另外如果大家对设计模式的**发布/订阅模式**熟悉的话，对Kafka的设计理念会更容易理解。

总的来说，Kafka由五大模块组成，大家要理解好这些模块的功能作用：消息生产者、消息消费者、`Broker`、主题`Topic`、分区`Partition`。

（1）消息生产者

消息生产者是消息的创造者，每发送一条消息都会发送到特定的主题上去。

（2）消息消费者

消息生产者和消费者都是Kafka的客户端，消息消费者顾名思义作为消息的读取者、消费者。同时Kafka很灵活的一点是，一个消费者可以订阅多个主题，而且一个主题消息也可被不同消息分组的多个消费者处理。这就给我们变化多端的业务设计带来了众多可能性了，方便大家自由发挥。

（3）`Broker`

孤零零部署在Linux的Kafka服务器被称为`Broker`，也就是我上文提到的`中间的消息服务系统`，大家不要小瞧他，单台Broker可以轻松处理**每秒百万级**的消息量。Broker日常工作内容就是接收消息生产者的消息，为每条消息设置偏移量，最后提交到磁盘进行持久化保存。

（4）主题`Topic`

上文我们知道Kafka的消息是有分类的，而分类的标识就是主题`Topic`。大家可以看下具体代码落地会更容易理解，消息生产者`Producer`发送给`clock-topic`主题，消息消费者监听消费`clock-topic`主题下的消息。

```java
// 消息生产者
public class Producer implements ApplicationRunner {
    @Resource
    private RedissonClient redissonClient;
    @Resource
    private KafkaTemplate<String, String> kafkaTemplate;
    
    @Override
    public void run(ApplicationArguments args) throws Exception {
        RBlockingQueue<Clock> blockingFairQueue = redissonClient.getBlockingQueue("delay_queue");

        while (true) {
            Clock clock = blockingFairQueue.take();
            kafkaTemplate.send("clock-topic", "key", clock.toString());
            log.info("time out: {} , clock created: {}", new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(new Date()), clock.getTime());
        }
    }
}
```

```java
    // 消息消费者
    @KafkaListener(topics = "clock-topic", groupId = "kafka-group")
    public void listener(ConsumerRecord<String, String> record, Acknowledgment ack) {
        log.info("listener get message: " + record.value());
        ack.acknowledge();
    }
```

（5）分区`Partition`

每一个主题下的消息都需要提交到Broker的磁盘里，假如我们搭建了三个Broker节点组成的Kafka集群，一般情况下同一个主题下的消息会被分到三个分区进行存储。说到这，由于顺序发送的消息是存储在不同分区中，我们无法保证消息被按**顺序消费**，只能保证**同一个分区**下的消息被顺序消费.







## 20240721：一条SQL，我怎么知道它有没使用到索引？

面试官看你简历写了`掌握MySQL`，那这道问题就是必考题。

检查是否使用索引可以利用**Explain关键字**来分析，它会模拟执行sql语句，查询出sql语句**执行的相关信息**，如哪些索引可以被命中、哪些索引实际被命中。

我说下Explain查询结果的几个关键字段。

（1）**type**

- cost：通过索引**一次**查询
- ref：使用到索引
- range: 使用到索引
- all：**全表扫描**

（2）**Extra**

- using filesort：使用外部文件排序，发生在无法使用索引的情况下

- using index：**where查询**的列**被**索引覆盖，直接通过索引就可以查询到数据

- using where：**where查询**的列，没有**全部被**索引覆盖

- using join buffer：使用了连接缓存

（3）**possible_key**

表示可以使用的索引

（4）**key**

表示实际使用的索引

如果简历你写了`精通MySQL`，那问的可就没这么简单。我可以问你在工作中紧急处理了哪些数据库重大事故，优化了哪些业务慢SQL、是怎么优化的、为什么这么做。
